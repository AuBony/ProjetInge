#Train test datasets
train_index_event <- sample(1:nrow(df_feature), 0.7 * nrow(df_feature))
y_train_event <- as.factor(df_feature[train_index_event, "event"])
x_train_event <- df_feature[train_index_event, 5:21]
y_test_event <- as.factor(df_feature[-train_index_event, "event"])
x_test_event <- as.data.frame(df_feature[-train_index_event, 5:21])
#RandomForest Model
model <- randomForest::randomForest(y_train_event ~ ., data = x_train_event,
ntree = 40,
importance = TRUE)
pred_test_1 <-  predict(model, newdata = x_test_event)
ERROR <- ERROR + get.error(y_test_event, pred_test_1)
SENS <- SENS + get.sensitivity(y_test_event,pred_test_1)
SPEC <- SPEC + get.specificity(y_test_event,pred_test_1)
}
#Save values
df_ERROR_window <- df_ERROR_window %>% add_row(window = window,
event_1 = nrow(df_event_1[df_event_1$event == "1",]),
event_0 = nrow(df_event_1[df_event_1$event == "0",]),
Error = ERROR / repet,
Sens = SENS / repet,
Spec = SPEC / repet)
cat("\n")
}
return(as.data.frame(df_ERROR_window))
}
# Execution
df_Error_window <- give_Error_window_length(from = 0.1, to = 1, by = 0.1, repet = 10, wav_path = "data/wav/", data = IIB2_df_wav)
# Execution
df_Error_window <- give_Error_window_length(from = 0.01, to = 1.01, by = 0.1, repet = 10, wav_path = "data/wav/", data = IIB2_df_wav)
by
# Execution
df_Error_window <- give_Error_window_length(from = 0.05, to = 1.05, by = 0.1, repet = 10, wav_path = "data/wav/", data = IIB2_df_wav)
df_Error_window
plot_dfERROR_window(df_Error_window)
write.table(df_Error_window, file = "data/error/IIB2_df_Error_window.txt")
# Functions
give_breaks <- function(frame_size = 0.1, ovlp_frame = 0, percent_expansion = 0, wav_path = "data/wav/", data = IIB3_df_wav){
# Goal : Give features of frames from IIB3_df_wav recordings for break sounds
# Input : list of labeled events
#         frame size, ovl_frame : percentage of overlap between frames within the same sound,
#         percent_expansion : percentage of the window size that will be taken to exceed on either side of the labelled area,
#         It means the beginning frame will have a proportion of percent_expansion % which will not be a break sound but a background noise sound.
#         Same for the ending frame.
# Output : Dataframe with features for each frame.
#Library
require(dplyr)
require(tuneR)
require(seewave)
#Initialise the dataframe
df_feature_event <- tibble(filename = character(),
start = numeric(),
end = numeric(),
event = numeric(),
th = numeric(),
maxdfreq = numeric(),
meandfreq = numeric(),
smean = numeric(),
ssd = numeric(),
ssem = numeric(),
smedian = numeric(),
smode = numeric(),
sQ25 = numeric(),
sQ75 = numeric(),
sIQR = numeric(),
scent = numeric(),
sskewness = numeric(),
skurtosis = numeric(),
ssfm = numeric(),
ssh = numeric())
#Browse through the recordings.
for (audio in unique(data[data$annotation == "croc", "filename"])){
cat(".")
crocs <- data %>% filter(filename ==  audio)
#Selection of breaks in a recording
for(l_croc in 1:nrow(crocs)){
#Definition of a sample area for our frames (we can define a slightly larger interval)
#Cutting into frames
#Checking if the break is long enough to be cut into frames
if (crocs[l_croc,"end"] + (frame_size*percent_expansion) - frame_size - crocs[l_croc,"start"] + (frame_size*percent_expansion) > frame_size ){
#Browse into a break sound
for (moment in seq(from =  crocs[l_croc,"start"] - (frame_size*percent_expansion), to = crocs[l_croc,"end"] + (frame_size*percent_expansion) - frame_size, by = frame_size * (1-ovlp_frame))){
wav_file <- readWave(paste0(wav_path, audio),
from = moment,
to = moment + frame_size,
units = "seconds")
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = TRUE, norm = FALSE))
#Data recording.
df_feature_event <- df_feature_event %>% add_row(
filename = audio,
start = moment,
end = moment + frame_size,
event = 1,
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
}
}
}
return(as.data.frame(df_feature_event))
}
give_no_event <- function(frame_size = 0.1, ovlp_frame = 0, wav_path = "data/wav/", data = IIB3_df_wav){
# Goal : Give features of frames from IIB3_df_wav recordings for background noises
# Input : list of labeled events
#         frame size, ovl_frame : percentage of overlap between frames within the same sound
# Output : Dataframe with features for each frame.
#         End of recordings are not sampled nor too short background noises parts.
#Library
require(dplyr)
require(tuneR)
require(seewave)
#Initialise the dataframe
df_feature_no_event <- tibble(filename = character(),
start = numeric(),
end = numeric(),
event = numeric(),
th = numeric(),
maxdfreq =  numeric(),
meandfreq =  numeric(),
smean =  numeric(),
ssd =  numeric(),
ssem =  numeric(),
smedian =  numeric(),
smode =  numeric(),
sQ25 =  numeric(),
sQ75 =  numeric(),
sIQR =  numeric(),
scent =  numeric(),
sskewness =  numeric(),
skurtosis =  numeric(),
ssfm =  numeric(),
ssh =  numeric())
#Browse into recordings
for (audio in unique(data$filename)){
cat("_")
no_event <- data %>% filter(filename ==  audio, annotation == "croc") #List of break events into the recording
#In case there is no break into the recording
if (dim(no_event)[1] == 0){
deb <- 0
audio_wav <- readWave(paste0(wav_path, audio), units = "seconds")
fin <- round(length(audio_wav@left) / audio_wav@samp.rate, 2)
for (moment in seq(from =  deb, to = fin - frame_size, by = frame_size * (1-ovlp_frame))){
wav_file <- readWave(paste0(wav_path, audio),
from = moment,
to = moment + frame_size,
units = "seconds")
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = TRUE, norm = FALSE))
#Data recording.
df_feature_no_event <- df_feature_no_event %>% add_row(
filename = audio,
start = moment,
end = moment + frame_size,
event = 0,
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
#In case there is at least one break into the recording
}else{
for (l_no_event in 1: nrow(no_event)){
#If there is only one break
if (l_no_event == 1){
deb <- 0
fin <- no_event$start[1]
}
#If there is more than one
if (l_no_event >1){
deb <- no_event$end[l_no_event - 1]
fin <- no_event$start[l_no_event]
}
#The duration of the break has to be longer than the frame size
if (fin - deb > frame_size){
for (moment in seq(from =  deb, to = fin - frame_size, by = frame_size * (1-ovlp_frame))){
wav_file <- readWave(paste0(wav_path, audio),
from = moment,
to = moment + frame_size,
units = "seconds")
wav_file <- tuneR::normalize(wav_file, center = TRUE)
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = TRUE, norm = FALSE))
#Data recording.
df_feature_no_event <- df_feature_no_event %>% add_row(
filename = audio,
start = moment,
end = moment + frame_size,
event = 0,
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
}
}
}
}
return(as.data.frame(df_feature_no_event))
}
#Libraries
require(readr)  # for read_csv()
require(dplyr)  # for mutate()
require(tidyr)  # for unnest()
require(purrr)  # for map(), reduce()
library(stringr) # for str_replace()
#Data manipulation
data_path <- "data/labels/labels_1/"
files <- dir(data_path, pattern = "*.txt")
data <- data_frame(filename = files) %>%
mutate(file_contents = map(filename,
~ read_delim(file.path(data_path, .),
delim="\t",
escape_double = FALSE,
col_names = c("start", "end", "annotation"),
trim_ws = TRUE)))
data_modif <- unnest(data, cols = c(file_contents))
# Add Cat and Kibble
data_modif_chat_kibble <- data_modif %>%
mutate(chat = as.character(map(strsplit(data_modif$filename, "_"), 1)),
kibble = as.character(map(strsplit(data_modif$filename, "_"), 2)))
# Add duration
data_modif_chat_kibble_duration <- data_modif_chat_kibble %>%  mutate(duration = end - start)
# Add id_label
df_txt <- cbind.data.frame(data_frame(id = seq(1, nrow(data_modif_chat_kibble_duration))), data_modif_chat_kibble_duration)
# Modify filename .txt to .wav
IIB3_df_wav <- df_txt
IIB3_df_wav$filename <- str_replace(df_txt$filename, ".txt", ".wav")
#Cleaning environment
remove(data, data_modif, data_modif_chat_kibble_duration, data_modif_chat_kibble,df_txt)
IIB3_y_train <- read.table("data/features/IIB3_y_train.txt")
IIB3_x_train <- read.table("data/features/IIB3_x_train.txt")
IIB3_y_test <- read.table("data/features/IIB3_y_test.txt")
IIB3_x_test <- read.table("data/features/IIB3_x_test.txt")
require(randomForest)
require(ROCR)
IIB3_model <- randomForest::randomForest(
IIB3_y_train ~ .,
data = IIB3_x_train,
ntree = 40,
mtry = 4,
x_test = IIB3_x_test,
y_test = IIB3_y_test,
importance = TRUE)
IIB3_model
pred_RF <- predict(IIB3_model, newdata = IIB3_x_test, type = "prob")
pred_class <-  prediction(pred_RF[,2], IIB3_y_test)
pred.test <- predict(IIB3_model, newdata = IIB3_x_test)
performance_RF <- performance(pred_class,measure = "tpr",x.measure= "fpr")
plot(performance_RF, col = 4, lwd = 2)
abline(0,1)
IIB3_y_train
IIB3_model <- randomForest::randomForest(
IIB3_y_train ~ .,
data = IIB3_x_train,
ntree = 40,
mtry = 4,
x_test = IIB3_x_test,
y_test = IIB3_y_test,
importance = TRUE)
class(IIB3_y_train)
IIB3_model <- randomForest::randomForest(
IIB3_y_train$x ~ .,
data = IIB3_x_train,
ntree = 40,
mtry = 4,
x_test = IIB3_x_test,
y_test = IIB3_y_test,
importance = TRUE)
IIB3_y_train$x
IIB3_y_train <- IIB3_y_train$x
IIB3_model <- randomForest::randomForest(
IIB3_y_train ~ .,
data = IIB3_x_train,
ntree = 40,
mtry = 4,
x_test = IIB3_x_test,
y_test = IIB3_y_test,
importance = TRUE)
y_train
IIB3_y_train
IIB3_y_train <- as.factor(IIB3_y_train)
IIB3_model <- randomForest::randomForest(
IIB3_y_train ~ .,
data = IIB3_x_train,
ntree = 40,
mtry = 4,
x_test = IIB3_x_test,
y_test = IIB3_y_test,
importance = TRUE)
IIB3_model
pred_RF <- predict(IIB3_model, newdata = IIB3_x_test, type = "prob")
pred_class <-  prediction(pred_RF[,2], IIB3_y_test)
pred.test <- predict(IIB3_model, newdata = IIB3_x_test)
performance_RF <- performance(pred_class,measure = "tpr",x.measure= "fpr")
plot(performance_RF, col = 4, lwd = 2)
abline(0,1)
IIB3_df_ERROR_ovl <- read.table(file = "data/error/IIB3_df_ERROR_ovl.txt")
IIB3_Error_cat <- read.table(file = "data/error/IIB3_Error_cat.txt")
IIB3_Error_kibble <- read.table(file = "data/error/IIB3_Error_kibble.txt")
IIB3_model <- randomForest::randomForest(
IIB3_y_train ~ .,
data = IIB3_x_train,
ntree = 40,
mtry = 4,
x_test = IIB3_x_test,
y_test = IIB3_y_test,
importance = TRUE)
IIB3_model
pred_RF <- predict(IIB3_model, newdata = IIB3_x_test, type = "prob")
pred_class <-  prediction(pred_RF[,2], IIB3_y_test)
pred.test <- predict(IIB3_model, newdata = IIB3_x_test)
performance_RF <- performance(pred_class,measure = "tpr",x.measure= "fpr")
plot(performance_RF, col = 4, lwd = 2)
abline(0,1)
require(ggplot2)
require(dplyr)
require(tidyr)
require(akima)
require(rgl)
require(lazyeval)
require(plotly)
# Cat
IIB3_Error_cat %>%
select(chat, ERROR_glob, ERROR_chat) %>%
gather("ERROR", "value", -chat) %>%
ggplot(aes(x= as.factor(chat), y = value, fill = ERROR)) +
geom_bar(stat="identity", position=position_dodge()) +
ggtitle("Loss of prediction quality on an unknown cat") +
xlab("")+
ylab("")+
theme_bw()
IIB3_Error_cat %>%
select(chat, class_1_glob, class_1_chat) %>%
gather("CLASS_1", "value", -chat) %>%
ggplot(aes(x= as.factor(chat), y = value, fill = CLASS_1)) +
geom_bar(stat="identity", position=position_dodge()) +
ggtitle("Loss of prediction quality on an unknown cat") +
xlab("")+
ylab("Error Class 1")+
theme_minimal()
IIB3_Error_kibble %>%
select(kibble, ERROR_glob, ERROR_kibble) %>%
gather("ERROR", "value", -kibble) %>%
ggplot(aes(x= as.factor(kibble), y = value, fill = ERROR)) +
geom_bar(stat="identity", position=position_dodge()) +
ggtitle("Quality prediction of an unknown kibble (Global Error)") +
xlab("")+
ylab("Global Error")+
theme_minimal()
IIB3_Error_kibble %>%
select(kibble, class_1_glob, class_1_kibble) %>%
gather("CLASS_1", "value", -kibble) %>%
ggplot(aes(x= as.factor(kibble), y = value, fill = CLASS_1)) +
geom_bar(stat="identity", position=position_dodge()) +
ggtitle("Quality prediction of an unknown kibble (Error on break class)") +
xlab("")+
ylab("Error Class 1")+
theme_minimal()
IIB3_Error_kibble %>%
select(kibble, class_0_glob, class_0_kibble) %>%
gather("CLASS_0", "value", -kibble) %>%
ggplot(aes(x= as.factor(kibble), y = value, fill = CLASS_0)) +
geom_bar(stat="identity", position=position_dodge()) +
ggtitle("Quality prediction of an unknown kibble (Error on background noise class)") +
xlab("")+
ylab("Error Class 0")+
theme_minimal()
IIB3_df_ERROR_ovl[which.min(IIB3_df_ERROR_ovl$class_error_0), ]
IIB3_df_ERROR_ovl[which.min(IIB3_df_ERROR_ovl$class_error_1), ]
ggplot(IIB3_df_ERROR_ovl, aes(x = class_error_1)) +
geom_histogram(color="black", fill="white", aes(y=..density..), bins = 30) +
geom_density(alpha=.2, fill="darkgreen") +
xlim(0,1)+
theme_bw()
ggplot(IIB3_df_ERROR_ovl, aes(x = class_error_0)) +
geom_histogram(color="black", fill="white", aes(y=..density..), bins = 30) +
geom_density(alpha=.2, fill="#FF6666") +
xlim(0,1)+
theme_bw()
#Libraries
require(readr)  # for read_csv()
require(dplyr)  # for mutate()
require(tidyr)  # for unnest()
require(purrr)  # for map(), reduce()
library(stringr) # for str_replace()
#Data manipulation
data_path <- "data/labels/labels_2/"
files <- dir(data_path, pattern = "*.txt")
data <- data_frame(filename = files) %>%
mutate(file_contents = map(filename,
~ read_delim(file.path(data_path, .),
delim="\t",
escape_double = FALSE,
col_names = c("start", "end", "annotation"),
trim_ws = TRUE)))
data_modif <- unnest(data, cols = c(file_contents))
# Add Cat and Kibble
data_modif_chat_kibble <- data_modif %>%
mutate(chat = as.character(map(strsplit(data_modif$filename, "_"), 1)),
kibble = as.character(map(strsplit(data_modif$filename, "_"), 2)))
# Add duration
data_modif_chat_kibble_duration <- data_modif_chat_kibble %>%  mutate(duration = end - start)
# Add id_label
df_txt <- cbind.data.frame(data_frame(id = seq(1, nrow(data_modif_chat_kibble_duration))), data_modif_chat_kibble_duration)
# Modify filename .txt to .wav
IIB4_df_wav <- df_txt
IIB4_df_wav$filename <- str_replace(df_txt$filename, ".txt", ".wav")
#Cleaning environment
remove(data, data_modif, data_modif_chat_kibble_duration, data_modif_chat_kibble,df_txt)
IIB4_break_train <- read.table("data/features/IIB4_break_train.txt"
)
IIB4_no_event_train <- read.table("data/features/IIB4_no_event_train.txt")
IIB4_break_test <- read.table("data/features/IIB4_break_test.txt")
IIB4_no_event_test<- read.table("data/features/IIB4_no_event_test.txt")
# Model
IIB4_model <- randomForest::randomForest(
IIB4_y_train ~ .,
data = IIB4_x_train,
ntree = 40,
mtry = 4,
x_test = IIB4_x_test,
y_test = IIB4_y_test,
importance = TRUE)
# IIB4_break_train <- read.table("data/features/IIB4_break_train.txt")
# IIB4_no_event_train <- read.table("data/features/IIB4_no_event_train.txt")
# IIB4_break_test <- read.table("data/features/IIB4_break_test.txt")
# IIB4_no_event_test<- read.table("data/features/IIB4_no_event_test.txt")
IIB4_y_train <- as.factor(c(IIB4_break_train$event, IIB4_no_event_train$event))
IIB4_x_train <- rbind.data.frame(IIB4_break_train[, 5:20], IIB4_no_event_train[, 5:20])
IIB4_y_test <- as.factor((c(IIB4_break_test$event, IIB4_no_event_test$event)))
IIB4_x_test <- rbind.data.frame(IIB4_break_test[, 5:20], IIB4_no_event_test[, 5:20])
# Model
IIB4_model <- randomForest::randomForest(
IIB4_y_train ~ .,
data = IIB4_x_train,
ntree = 40,
mtry = 4,
x_test = IIB4_x_test,
y_test = IIB4_y_test,
importance = TRUE)
IIB4_model
varImpPlot(IIB4_model)
pred_RF <- predict(IIB4_model, newdata = IIB4_x_test, type = "prob")
pred_class <-  prediction(pred_RF[,2], IIB4_y_test)
pred.test <- predict(IIB4_model, newdata = IIB4_x_test)
performance_RF <- performance(pred_class, measure = "tpr",x.measure= "fpr")
plot(performance_RF, col = 4, lwd = 2)
abline(0,1)
break_1 <- read.table("data/features/IIB5_break_1.txt")
event_1 <- read.table("data/features/IIB5_event_1.txt")
break_2 <- read.table("data/features/IIB5_break_2.txt")
event_2 <- read.table("data/features/IIB5_event_2.txt")
require(FactoMineR)
require(ggplot2)
#Visualisation
break_1$method <- as.factor(break_1$method)
break_2$method <- as.factor(break_2$method)
res.PCA<-PCA(rbind.data.frame(break_1, break_2),quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Variables of ACP")
plotellipses(res.PCA, keepvar=5, invisible=c('quali','ind.sup'),title="Breaks",cex=1.6,cex.main=1.6,cex.axis=1.6, label ='none')
event_1$method <- as.factor(event_1$method)
event_2$method <- as.factor(event_2$method)
res.PCA<-PCA(rbind.data.frame(event_1, event_2), quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Variables of ACP")
plotellipses(res.PCA, keepvar=5,invisible=c('quali','ind.sup'),title="Background noise",cex=1.5,cex.main=1.5,cex.axis=1.5,label ='none')
data.frame(type = rep(c("break", "no_event"), 2),
method = rep(c("1","2"), each = 2),
value = c(nrow(break_1), nrow(event_1), nrow(break_2), nrow(event_2))) %>%
ggplot(aes(x=method, y=value, fill=type)) +
geom_bar(stat="identity", width = 0.2) +
scale_fill_brewer(palette="Pastel2") +
ylab('Number of frames')+
theme_light()
