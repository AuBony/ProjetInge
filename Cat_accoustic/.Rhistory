ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
}
}
}
return(as.data.frame(df_feature_no_event))
}
give_break_1 <- function(frame_size = 0.1, ovlp_frame = 0, percent_expansion = 0, wav_path = "data/wav/", data = df_wav_1){
# Goal : Give features of frames from IIB3_df_wav recordings for break sounds
# Input : list of labeled events
#         frame size, ovl_frame : percentage of overlap between frames within the same sound,
#         percent_expansion : percentage of the window size that will be taken to exceed on either side of the labelled area,
#         It means the beginning frame will have a proportion of percent_expansion % which will not be a break sound but a background noise sound.
#         Same for the ending frame.
# Output : Dataframe with features for each frame.
#Library
require(dplyr)
require(tuneR)
require(seewave)
#Initialise the dataframe
df_feature_event <- tibble(filename = character(),
start = numeric(),
end = numeric(),
event = numeric(),
method = factor(levels = c('1', '2')),
th = numeric(),
maxdfreq = numeric(),
meandfreq = numeric(),
smean = numeric(),
ssd = numeric(),
ssem = numeric(),
smedian = numeric(),
smode = numeric(),
sQ25 = numeric(),
sQ75 = numeric(),
sIQR = numeric(),
scent = numeric(),
sskewness = numeric(),
skurtosis = numeric(),
ssfm = numeric(),
ssh = numeric())
#Browse through the recordings.
for (audio in unique(data[data$annotation == "croc", "filename"])){
cat(".")
crocs <- data %>% filter(filename ==  audio)
#Selection of breaks in a recording
for(l_croc in 1:nrow(crocs)){
#Definition of a sample area for our frames (we can define a slightly larger interval)
#Cutting into frames
#Checking if the break is long enough to be cut into frames
if (crocs[l_croc,"end"] + (frame_size*percent_expansion) - frame_size - crocs[l_croc,"start"] + (frame_size*percent_expansion) > frame_size ){
#Browse into a break sound
for (moment in seq(from =  crocs[l_croc,"start"] - (frame_size*percent_expansion), to = crocs[l_croc,"end"] + (frame_size*percent_expansion) - frame_size, by = frame_size * (1-ovlp_frame))){
wav_file <- readWave(paste0(wav_path, audio),
from = moment,
to = moment + frame_size,
units = "seconds")
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = TRUE, norm = FALSE))
#Data recording
df_feature_event <- df_feature_event %>% add_row(
filename = audio,
start = moment,
end = moment + frame_size,
event = 1,
method = as.factor(1),
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
}
}
}
return(as.data.frame(df_feature_event))
}
give_no_event_1 <- function(frame_size = 0.1, ovlp_frame = 0, wav_path = "data/wav/", data = df_wav_1){
# Goal : Give features of frames from IIB3_df_wav recordings for background noises
# Input : list of labeled events
#         frame size, ovl_frame : percentage of overlap between frames within the same sound
# Output : Dataframe with features for each frame.
#         End of recordings are not sampled nor too short background noises parts.
#Library
require(dplyr)
require(tuneR)
require(seewave)
#Initialise the dataframe
df_feature_no_event <- tibble(filename = character(),
start = numeric(),
end = numeric(),
event = numeric(),
method = factor(levels = c('1', '2')),
th = numeric(),
maxdfreq =  numeric(),
meandfreq =  numeric(),
smean =  numeric(),
ssd =  numeric(),
ssem =  numeric(),
smedian =  numeric(),
smode =  numeric(),
sQ25 =  numeric(),
sQ75 =  numeric(),
sIQR =  numeric(),
scent =  numeric(),
sskewness =  numeric(),
skurtosis =  numeric(),
ssfm =  numeric(),
ssh =  numeric())
#Browse into recordings
for (audio in unique(data$filename)){
cat("_")
no_event <- data %>% filter(filename ==  audio, annotation == "croc") #liste des crocs dans un enregistrement
#In case there is no break into the recording
if (dim(no_event)[1] == 0){
deb <- 0
audio_wav <- readWave(paste0(wav_path, audio), units = "seconds")
fin <- round(length(audio_wav@left) / audio_wav@samp.rate, 2)
for (moment in seq(from =  deb, to = fin - frame_size, by = frame_size * (1-ovlp_frame))){
wav_file <- readWave(paste0(wav_path, audio),
from = moment,
to = moment + frame_size,
units = "seconds")
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = TRUE, norm = FALSE))
#Data recording.
df_feature_no_event <- df_feature_no_event %>% add_row(
filename = audio,
start = moment,
end = moment + frame_size,
event = 0,
method = as.factor(1),
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
#In case there is at least one break into the recording
}else{
for (l_no_event in 1: nrow(no_event)){
#If there is only one break
if (l_no_event == 1){
deb <- 0
fin <- no_event$start[1]
}
#If there is more than one
if (l_no_event >1){
deb <- no_event$end[l_no_event - 1]
fin <- no_event$start[l_no_event]
}
#The duration of the break has to be longer than the frame size
if (fin - deb > frame_size){
for (moment in seq(from =  deb, to = fin - frame_size, by = frame_size * (1-ovlp_frame))){
wav_file <- readWave(paste0(wav_path, audio),
from = moment,
to = moment + frame_size,
units = "seconds")
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = TRUE, norm = FALSE))
#Data recording.
df_feature_no_event <- df_feature_no_event %>% add_row(
filename = audio,
start = moment,
end = moment + frame_size,
event = 0,
method = as.factor(1),
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
}
}
}
}
return(as.data.frame(df_feature_no_event))
}
give_break_2 <- function(shift = 0, wav_path = "data/wav/", data = df_wav_2){
# Goal : Give features of frames from IIB4_df_wav recordings for break sounds
# Input : list of labeled events
#         shift : percent of sound duration used to shift.
#         If shift > 0, you'll get 3 frames for each sound instead of one.
#         Frame 1 : the actual sound
#         Frame 2 : the sound shifted by shift% of the duration of the sound on the right
#         Frame 3 : the sound shifted by shift% of the duration of the sound on the left
# Output : Dataframe with features for each frame.
#Library
require(dplyr)
require(tuneR)
require(seewave)
#Initialise the dataframe
df_feature_event <- tibble(filename = character(),
start = numeric(),
end = numeric(),
event = factor(levels = c('0','1')),
method = factor(levels = c('1','2')),
th = numeric(),
maxdfreq = numeric(),
meandfreq = numeric(),
smean = numeric(),
ssd = numeric(),
ssem = numeric(),
smedian = numeric(),
smode = numeric(),
sQ25 = numeric(),
sQ75 = numeric(),
sIQR = numeric(),
scent = numeric(),
sskewness = numeric(),
skurtosis = numeric(),
ssfm = numeric(),
ssh = numeric())
#Browse through the recordings.
for (audio in unique(data[, "filename"])){
print(audio)
crocs <- data %>% filter(filename ==  audio)
#Selection of breaks in a recording
for(l_croc in 1:nrow(crocs)){
#Only one frame per sound
if (shift == 0){
wav_file <- readWave(paste0(wav_path, audio),
from = crocs$start[l_croc],
to = crocs$end[l_croc],
units = "seconds")
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = FALSE, norm = FALSE))
#Data recording
df_feature_event <- df_feature_event %>% add_row(
filename = audio,
start =  crocs$start[l_croc],
end =  crocs$end[l_croc],
event = as.factor(1),
method = as.factor(2),
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
# Here shift > 0, we check that the shift to the left does not take us out of the recording
} else if((crocs[l_croc,"start"] * (1 - shift) > 0)){
e <- crocs[l_croc,"duration"] * shift
moment <- list(c(crocs[l_croc,"start"] - e, crocs[l_croc, "end"] - e),
c(crocs[l_croc,"start"], crocs[l_croc, "end"]),
c(crocs[l_croc,"start"] + e, crocs[l_croc, "end"] + e))
for (k in 1:3){
wav_file <- readWave(paste0(wav_path, audio),
from = moment[[k]][1],
to = moment[[k]][2],
units = "seconds")
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = FALSE, norm = FALSE))
#Data recording
df_feature_event <- df_feature_event %>% add_row(
filename = audio,
start =  moment[[k]][1],
end =  moment[[k]][2],
event = as.factor(1),
method = as.factor(2),
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
}
}
}
return(as.data.frame(df_feature_event))
}
give_no_event_2 <- function(frame_size = 0.02, nb_ech = 10, wav_path = "data/wav/", data = df_wav_2){
# Goal : Give features of frames from IIB4_df_wav recordings for background noises
# Input : list of labeled events
#         frame size, nb_ech : number of frame per part of background noise.
# Output : Dataframe with features for each frame.
#         End of recordings are not sampled nor too short background noises parts.
#Library
require(pracma)
require(dplyr)
require(tuneR)
require(seewave)
#Initialise the dataframe
df_feature_no_event <- tibble(filename = character(),
start = numeric(),
end = numeric(),
event = factor(levels = c('0','1')),
method = factor(levels = c('1','2')),
th = numeric(),
maxdfreq = numeric(),
meandfreq = numeric(),
smean = numeric(),
ssd = numeric(),
ssem = numeric(),
smedian = numeric(),
smode = numeric(),
sQ25 = numeric(),
sQ75 = numeric(),
sIQR = numeric(),
scent = numeric(),
sskewness = numeric(),
skurtosis = numeric(),
ssfm = numeric(),
ssh = numeric())
#Browse into recordings
for (audio in unique(data[, "filename"])){
print(audio)
no_event <- data %>% filter(filename ==  audio)
for (l_no_event in 1:(nrow(no_event)+1)){
if (l_no_event == 1){
deb <- 0
fin <- no_event$start[l_no_event]
} else if (l_no_event > nrow(no_event)){
deb <- no_event$end[l_no_event - 1]
fin <- duration(readWave(filename = paste0(wav_path, audio)))
} else if (l_no_event >1){
deb <- no_event$end[l_no_event - 1]
fin <- no_event$start[l_no_event]
}
if (fin - deb > nb_ech * frame_size){
deb_rand <- round(runif(min =  deb, max = (fin-frame_size), n = nb_ech),digits =  2)
for (moment in deb_rand){
wav_file <- readWave(paste0(wav_path, audio),
from = moment,
to = moment + frame_size,
units = "seconds")
wav_file <- tuneR::normalize(wav_file, center = TRUE)
#Extraction of spectro properties
sp <- seewave::specprop(seewave::spec(wav_file@left, f = wav_file@samp.rate, plot = FALSE, scaled = TRUE, norm = FALSE))
#Data recording
df_feature_no_event <- df_feature_no_event %>% add_row(
filename = audio,
start = moment,
end = moment + frame_size,
event = as.factor(0),
method = as.factor(2),
th = seewave::th(env(wav_file, plot = FALSE)),
maxdfreq = max(dfreq(wav_file, plot = FALSE)[,2]),
meandfreq = mean(dfreq(wav_file, plot = FALSE)[,2]),
smean = sp$mean,
ssd = sp$sd,
ssem = sp$sem,
smedian = sp$median,
smode = sp$mode,
sQ25 = sp$Q25,
sQ75 = sp$Q75,
sIQR = sp$IQR,
scent = sp$cent,
sskewness = sp$skewness,
skurtosis = sp$kurtosis,
ssfm = sp$sfm,
ssh = sp$sh)
}
}
}
}
return(as.data.frame(df_feature_no_event))
}
## DATA ----
break_1 <- give_break_1(frame_size = 0.1, ovlp_frame = 0, percent_expansion = 0, wav_path = "data/wav/", data = df_wav_1)
event_1 <- give_no_event_1(frame_size = 0.1, ovlp_frame = 0, wav_path = "data/wav/", data = df_wav_1)
break_2 <- give_break_2(shift = 0, wav_path = "data/wav/", data = df_wav_2)
event_2 <- give_no_event_2(frame_size = 0.02, nb_ech = 10, wav_path = "data/wav/", data = df_wav_2)
break_1 <- give_break_1(frame_size = 0.1, ovlp_frame = 0, percent_expansion = 0, wav_path = "data/wav/", data = df_wav_1)
event_1 <- give_no_event_1(frame_size = 0.1, ovlp_frame = 0, wav_path = "data/wav/", data = df_wav_1)
break_2 <- give_break_2(shift = 0, wav_path = "data/wav/", data = df_wav_2)
event_2 <- give_no_event_2(frame_size = 0.02, nb_ech = 10, wav_path = "data/wav/", data = df_wav_2)
write.table(break_1, file = "data/features/IIB5_break_1.txt")
write.table(break_2, file = "data/features/IIB5_break_2.txt")
write.table(event_1, file = "data/features/IIB5_event_1.txt")
write.table(event_2, file = "data/features/IIB5_event_2.txt")
break_1 <- read.table("data/features/IIB5_break_1.txt")
event_1 <- read.table("data/features/IIB5_event_1.txt")
break_2 <- read.table("data/features/IIB5_break_2.txt")
event_2 <- read.table("data/features/IIB5_event_2.txt")
require(FactoMineR)
res.PCA<-PCA(rbind.data.frame(croc_1, croc_2),quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Graphe des variables de l'ACP")
plotellipses(res.PCA, keepvar=5,invisible=c('quali','ind.sup'),title="Graphe des Crocs",cex=1.6,cex.main=1.6,cex.axis=1.6,label ='none')
res.PCA<-PCA(rbind.data.frame(event_1, event_2),quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Graphe des variables de l'ACP")
plotellipses(res.PCA, keepvar=5,invisible=c('quali','ind.sup'),title="Graphe des individus de l'ACP",cex=1.5,cex.main=1.5,cex.axis=1.5,label ='none')
data.frame(type = rep(c("croc", "no_event"), 2),
method = rep(c("1","2"), each = 2),
value = c(nrow(croc_1), nrow(event_1), nrow(croc_2), nrow(event_2))) %>%
ggplot(aes(x=method, y=value, fill=type)) +
geom_bar(stat="identity", width = 0.2) +
scale_fill_brewer(palette="Pastel2") +
theme_light()
res.PCA<-PCA(rbind.data.frame(croc_1, croc_2),quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
res.PCA<-PCA(rbind.data.frame(break_1, break_2),quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Graphe des variables de l'ACP")
plotellipses(res.PCA, keepvar=5,invisible=c('quali','ind.sup'),title="Graphe des Crocs",cex=1.6,cex.main=1.6,cex.axis=1.6,label ='none')
res.PCA<-PCA(rbind.data.frame(event_1, event_2),quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Graphe des variables de l'ACP")
plotellipses(res.PCA, keepvar=5,invisible=c('quali','ind.sup'),title="Graphe des individus de l'ACP",cex=1.5,cex.main=1.5,cex.axis=1.5,label ='none')
data.frame(type = rep(c("croc", "no_event"), 2),
method = rep(c("1","2"), each = 2),
value = c(nrow(croc_1), nrow(event_1), nrow(croc_2), nrow(event_2))) %>%
ggplot(aes(x=method, y=value, fill=type)) +
geom_bar(stat="identity", width = 0.2) +
scale_fill_brewer(palette="Pastel2") +
theme_light()
data.frame(type = rep(c("break", "no_event"), 2),
method = rep(c("1","2"), each = 2),
value = c(nrow(break_1), nrow(event_1), nrow(break_2), nrow(event_2))) %>%
ggplot(aes(x=method, y=value, fill=type)) +
geom_bar(stat="identity", width = 0.2) +
scale_fill_brewer(palette="Pastel2") +
theme_light()
require(ggplot2)
data.frame(type = rep(c("break", "no_event"), 2),
method = rep(c("1","2"), each = 2),
value = c(nrow(break_1), nrow(event_1), nrow(break_2), nrow(event_2))) %>%
ggplot(aes(x=method, y=value, fill=type)) +
geom_bar(stat="identity", width = 0.2) +
scale_fill_brewer(palette="Pastel2") +
theme_light()
# Number of frame
data.frame(type = rep(c("break", "no_event"), 2),
method = rep(c("1","2"), each = 2),
value = c(nrow(break_1), nrow(event_1), nrow(break_2), nrow(event_2))) %>%
ggplot(aes(x=method, y=value, fill=type)) +
geom_bar(stat="identity", width = 0.2) +
scale_fill_brewer(palette="Pastel2") +
ylab('Number of frames')+
theme_light()
plot.PCA(res.PCA,choix='var',title="Graphe des variables de l'ACP")
#Visualisation
res.PCA<-PCA(rbind.data.frame(break_1, break_2),quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Graphe des variables de l'ACP")
Factoshiny(rbind.data.frame(break_1, break_2))
library(Factoshiny)
Factoshiny(rbind.data.frame(break_1, break_2))
break_1$method
#Visualisation
break_1$method <- as.factor(break_1$method)
break_2$method <- as.factor(break_2$method)
res.PCA<-PCA(rbind.data.frame(break_1, break_2),quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Graphe des variables de l'ACP")
plotellipses(res.PCA, keepvar=5, invisible=c('quali','ind.sup'),title="Graphe des Crocs",cex=1.6,cex.main=1.6,cex.axis=1.6, label ='none')
event_1$method <- as.factor(event_1$method)
event_1$method <- as.factor(event_1$method)
event_2$method <- as.factor(event_2$method)
res.PCA<-PCA(rbind.data.frame(event_1, event_2), quali.sup=c(1,4,5),quanti.sup=c(2,3),graph=FALSE)
plot.PCA(res.PCA,choix='var',title="Variables of ACP")
plotellipses(res.PCA, keepvar=5,invisible=c('quali','ind.sup'),title="Background noise",cex=1.5,cex.main=1.5,cex.axis=1.5,label ='none')
